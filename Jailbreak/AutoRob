local Services = setmetatable({}, {
    __index = function(_, service)
        if ypcall(function()game:GetService(service)end) then
            return game:GetService(service)
        end
        return nil
    end
})

local Players = Services.Players
local LocalPlayer = Players.LocalPlayer
local PathfindingService = Services.PathfindingService
local Character, Root, Humanoid = nil,nil,nil

local FreeVehicles = {"Camaro" ,"Jeep"}
local BlacklistVehicles = {}
local Specs = require(Services.ReplicatedStorage.Module.UI).CircleAction.Specs
local GetLocalVehiclePacket = require(Services.ReplicatedStorage.Game.Vehicle).GetLocalVehiclePacket
local RobberyConsts = require(Services.ReplicatedStorage.Game.Robbery.RobberyConsts)
local Puzzle = getupvalue(require(Services.ReplicatedStorage.Game.Robbery.PuzzleFlow).Init, 3)
local RobberyState = Services.ReplicatedStorage.RobberyState
local Jewelry = workspace.Jewelrys:GetChildren()[1]
local attemptPunch = getupvalue(require(Services.ReplicatedStorage.Game.DefaultActions).punchButton.onPressed, 1).attemptPunch
local Stepped = {}

function RegisterCharacter(Char)
    Character, Root, Humanoid = Char, Char:WaitForChild("HumanoidRootPart", 2873), Char:WaitForChild("Humanoid", 2873)
    Humanoid.Died:Connect(function()
        Character, Root, Humanoid = nil,nil,nil
    end)
end

RegisterCharacter(LocalPlayer.Character)
LocalPlayer.CharacterAdded:Connect(RegisterCharacter)

function PathFind(Start, Destination, Params)
    Params = Params or {}
    local DefaultParams = {
        AgentCanJump = true,
        AgentHeight = 5,
        AgentRadius = 2,
        WaypointSpacing = 4
    }
    for k, v in pairs(DefaultParams) do
        Params[k] = Params[k] or DefaultParams[k]
    end
    local Path = PathfindingService:CreatePath(Params)
    local success = pcall(function()
        Path:ComputeAsync(Start, Destination)
    end)
    if success then
        if Path.Status == Enum.PathStatus.Success then
            return Path:GetWaypoints()
        else
            return nil
        end
    else
        return nil
    end
end

function Create(Inst, Parent, Config)
    local Inst = Instance.new(Inst, Parent)
    for property, val in pairs(Config) do
        Inst[property] = val
    end
    return Inst
end

function rayCast(Pos, Dir)
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {workspace:FindFirstChild("Rain"), workspace.Vehicles}
	raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
	return workspace:Raycast(Pos, Dir, raycastParams)
end

function FindEscape()
	local topRoofPosition = rayCast(Root.Position + Vector3.new(0, 1000, 0), Vector3.new(0, -2000, 0)).Position
	local Path = PathFind(topRoofPosition, Root.Position)
	if Path then
		local Waypoints = Path
		local escapePath = {}
		for i = #Waypoints, 1, -1 do
			table.insert(escapePath, Waypoints[i].Position)
			if not rayCast(Waypoints[i].Position, Vector3.new(0, 1000, 0)) then
                table.insert(escapePath, Waypoints[i - 1].Position)
				return escapePath
			end
		end
    else
        return nil
	end
end

function isVehicle(v)
    return v and v:FindFirstChild("Engine") and v:FindFirstChild("Seat") and v.Seat:FindFirstChild("PlayerName") and v.Seat:FindFirstChild("Player")
end

function getNearestVehicle(minDistance)
    local nearest,minDistance = nil, minDistance or 9e9
    for i, v in pairs(workspace.Vehicles:GetChildren()) do
        if table.find(FreeVehicles, v.Name) and not table.find(BlacklistVehicles, v) and isVehicle(v) and v.Seat.Player.Value == false then
            local distance = (v.Engine.Position - Root.Position).Magnitude
            if distance < minDistance then
                nearest,minDistance = v,distance
            end
        end
    end
    return nearest
end

function getNearestSpawn()
    local nearest,minDistance = nil, 9e9
    for i, v in pairs(workspace.VehicleSpawns:GetChildren()) do
        local distance = (v.Region.Position - Root.Position).Magnitude
        if table.find(FreeVehicles, v.Name) and distance < minDistance then
            nearest,minDistance = v,distance
        end
    end
    return nearest
end

function teleport(Destination, Mode, Speed)
	if (Mode == "linear" or Mode == "above") and (Destination - Root.Position).Magnitude < 1 then return end
    local BV = Create("BodyVelocity", Root, {
        Velocity = Vector3.new(),
        MaxForce = Vector3.new(1,1,1) * 9e9
    })
    if Mode == "linear" then
        local StartPos = Root.Position
        local Dir = (Destination - StartPos)
        for Lerp = 0, Dir.Magnitude, (Speed or 4) do
            if Humanoid.Sit then
                attemptJump()
            end
            Root.CFrame = CFrame.new(StartPos) + (Dir.Unit * Lerp)
            wait()
        end
        Root.CFrame = CFrame.new(Destination)
    elseif Mode == "above" then
        local Y = math.random(300, 400)
        local StartPos = Vector3.new(Root.Position.X, Y, Root.Position.Z)
        local Dir = (Vector3.new(Destination.X, Y, Destination.Z) - StartPos)
        for Lerp = 0, Dir.Magnitude, (Speed or 4) do
            if Humanoid.Sit then
                attemptJump()
            end
            Root.CFrame = CFrame.new(StartPos) + (Dir.Unit * Lerp)
            wait()
        end
        Root.CFrame = CFrame.new(Destination)
    elseif Mode == "vehicle" then
        repeat
            if Character:FindFirstChild("InVehicle") then
                local currentVehicle = GetLocalVehiclePacket().Model
				local root = currentVehicle.PrimaryPart
                local BV = Create("BodyVelocity", root, {
                    Velocity = Vector3.new(),
                    MaxForce = Vector3.new(1,1,1) * 9e9
                })
                if speed == math.huge then
                    repeat
                        root.CFrame = CFrame.new(Destination)
                        wait()
                    until not Character:FindFirstChild("InVehicle")
                else
                    local Y = math.random(300, 400)
                    local StartPos = Vector3.new(root.Position.X, Y, root.Position.Z)
                    local Dir = (Vector3.new(Destination.X, Y, Destination.Z) - StartPos)
                    for Lerp = 0, Dir.Magnitude, (Speed or 11) do
                        if not Character:FindFirstChild("InVehicle") then
                            break
                        end
                        root.CFrame = CFrame.new(StartPos) + (Dir.Unit * Lerp)
                        wait()
                    end
                    root.CFrame = CFrame.new(Destination)
                end
				BV:Destroy()
            else
                findEnterVehicle()
            end
        until (Destination - Root.Position).Magnitude < 5
    elseif Mode == "path" then
        for i,v in pairs(Destination) do
			print(type(v))
            teleport((type(v) == "userdata" and v.Position or v) + Vector3.new(0, 3, 0), "linear", Speed or 2)
        end
    end
    BV:Destroy()
end

function findEnterVehicle()
	local nearestSpawn = getNearestSpawn()
    local nearestVehicle = getNearestVehicle()
	local distanceToSpawn = (nearestSpawn.Region.Position - Root.Position).Magnitude
    local distanceToVehicle do
        if nearestVehicle ~= nil then
            distanceToVehicle = (nearestVehicle.Engine.Position - Root.Position).Magnitude
        end
    end
    if nearestVehicle == nil or (distanceToVehicle - 300 > distanceToSpawn) then
        repeat
            if (nearestSpawn.Region.Position - Root.Position).Magnitude > 10 then
                teleport(nearestSpawn.Region.Position, "above")
            end
            wait(0.5)
        until getNearestVehicle(20)
        nearestVehicle = getNearestVehicle(20)
    else
        teleport(nearestVehicle.Engine.Position, "above")
    end
    if nearestVehicle then
        local skipThisCar = false
        repeat
            if (nearestVehicle.PrimaryPart.Position - Root.Position).Magnitude > 10 then
                teleport(nearestVehicle.Engine.Position, "above")
            end
            for i,v in pairs(Specs) do
                if (v.Name == "Enter Driver" or v.Name == "Hijack") and v.Part == nearestVehicle.Seat then
                    v:Callback(true)
					break
                end
            end
            wait()
            if LocalPlayer.PlayerGui.NotificationGui.ContainerNotification.Message.Text:match("Cannot use vehicle here") and game:GetService("Players").LocalPlayer.PlayerGui.NotificationGui.Enabled then
                LocalPlayer.PlayerGui.NotificationGui.Enabled = false
                table.insert(BlacklistVehicles, nearestVehicle)
            end
            for i,v in pairs(LocalPlayer.PlayerGui:GetDescendants()) do
                if v:IsA("TextLabel") then
                    if v.Text:match("That vehicle is locked") and v.Visible then
                        v.Visible = false
                        table.insert(BlacklistVehicles, nearestVehicle)
                        break
                    end
                end
            end
        until table.find(BlacklistVehicles, v) or not isVehicle(nearestVehicle) or nearestVehicle.Seat.Player.Value
	end
end

function Escape()
	if not rayCast(Root.Position, Vector3.new(0, 1000, 0)) then return end
    local escapePath = FindEscape()
    if escapePath then
        teleport(escapePath, "path")
        return true
    else
        return false
    end
end

function attemptJump()
    repeat
        Services.VirtualInputManager:SendKeyEvent(true, "Space", false, game)
        wait()
        Services.VirtualInputManager:SendKeyEvent(false, "Space", false, game)
		wait(0.5)
    until not Humanoid.Sit
end


local Robbery = {
    Bank = {
        id = RobberyConsts.ENUM_ROBBERY.BANK,
        Open = false
    },
    Jewelry = {
        id = RobberyConsts.ENUM_ROBBERY.JEWELRY,
        Open = false
    },
    Museum = {
        id = RobberyConsts.ENUM_ROBBERY.MUSEUM,
        Open = false
    },
    PowerPlant = {
        id = RobberyConsts.ENUM_ROBBERY.POWER_PLANT,
        Open = false
    },
    NightTrain = {
        id = RobberyConsts.ENUM_ROBBERY.TRAIN_PASSENGER,
        Open = false
    },
    CargoTrain = {
        id = RobberyConsts.ENUM_ROBBERY.TRAIN_CARGO,
        Open = false
    },
    CargoShip = {
        id = RobberyConsts.ENUM_ROBBERY.CARGO_SHIP,
        Open = false
    },
    CargoPlane = {
        id = RobberyConsts.ENUM_ROBBERY.CARGO_PLANE,
        Open = false
    },
    Donut = {
        id = RobberyConsts.ENUM_ROBBERY.STORE_DONUT,
        Open = false
    },
    Gas = {
        id = RobberyConsts.ENUM_ROBBERY.STORE_GAS,
        Open = false
    },
    Tomb = {
        id = RobberyConsts.ENUM_ROBBERY.TOMB,
        Open = false
    }
}

for i, robberyState in pairs(RobberyState:GetChildren()) do
    for i2, robberyData in pairs(Robbery) do
        if robberyState.Name == tostring(robberyData.id) then
            --[1 = Open, 2 = Store is in robbery, 3 = Closed
            robberyData.Open = (robberyState.Value ~= 3)
            robberyState:GetPropertyChangedSignal("Value"):Connect(function()
                robberyData.Open = (robberyState.Value ~= 3)
            end)
            break
        end
    end
end

require(Services.ReplicatedStorage.Game.Paraglide).IsFlying = function()
    return tostring(getfenv(2).script) == "Falling"
end

function isBagFull()
    if not LocalPlayer.PlayerGui.RobberyMoneyGui.Enabled then
        return false
    end
    local moneys = string.split(LocalPlayer.PlayerGui.RobberyMoneyGui.Container.Bottom.Progress.Amount.Text, " / ")
    return moneys[1] == moneys[2]
end

function connectStep(name, func)
    Stepped[name] = Services.RunService.Stepped:Connect(func)
end
function disconnectStep(name)
    if Stepped[name] then
		Stepped[name]:Disconnect()
	end
end

function attemptSell()
	local powerPlant = LocalPlayer.PlayerGui:FindFirstChild("PowerPlantRobberyGui")
	repeat
		teleport(Vector3.new(2280, 23, -2064), "vehicle")
		wait(0.5)
		attemptJump()
		teleport(Vector3.new(2227, 19, -2455), "linear")
		teleport(Vector3.new(2292, 19, -2588), "linear")
		wait(1)
		teleport(Vector3.new(2227, 19, -2455), "linear")
		teleport(Vector3.new(2280, 23, -2064), "linear")
	until powerplant and not LocalPlayer.PlayerGui:FindFirstChild("PowerPlantRobberyGui") or not isBagFull()
end

function robJewelry()
    for i, v in next, Jewelry:GetDescendants() do
        if (v.ClassName == "TouchInterest" or v.ClassName == "TouchTransmitter") and v.Parent.Name ~= "LaserTouch" then
            v.Parent:Destroy()
        end
    end
    Escape()
    teleport(Vector3.new(118, 19, 1373), "vehicle")
    wait(0.5)
    attemptJump()
    teleport(Vector3.new(137, 19, 1347), "linear", 4)
    teleport(Vector3.new(135, 18, 1336), "linear", 2)
    local boxes = Jewelry.Boxes:GetChildren()
    table.sort(boxes, function(a, b)
        return a.Position.Y < b.Position.Y and (Vector3.new(a.Position.X, 0, a.Position.Z) - Vector3.new(Root.Position.X, 0, Root.Position.Z)).Magnitude < (Vector3.new(b.Position.X, 0, b.Position.Z) - Vector3.new(Root.Position.X, 0, Root.Position.Z)).Magnitude
    end)
    for i,box in pairs(boxes) do
        if isBagFull() or Robbery.Jewelry.Open == false then
            break
        end
        if box.Transparency < 0.9 then
            local PathToBox = PathFind(Root.Position, box.Position + box.CFrame.LookVector * 2.5)
            if PathToBox then
                teleport(PathToBox, "path")
                Root.CFrame = CFrame.new(Root.Position, box.Position)
            end
            for i = 1, 5 do
                attemptPunch()
                wait(0.5)
                if box.Transparency > 0.9 then
                    break
                end
            end
			Root.Anchored = false
        end
    end
    if isBagFull() then
        local PathToExit = PathFind(Root.Position, Vector3.new(126, 118, 1285))
        if PathToExit then
            teleport(PathToExit, "path", 2)
            teleport(Vector3.new(128, 118, 1331), "linear")
        end
        repeat
            teleport(Vector3.new(-247, 18, 1616), "above")
			wait(1)
        until not isBagFull()
		Robbery.Jewelry.Open = false
    end
end 

function robPower()
    Escape()
	teleport(Vector3.new(63, 23, 2344), "vehicle")
	wait(0.5)
	attemptJump()
	teleport(Vector3.new(89, 23, 2326), "linear")
	connectStep("openPuzzle", function()
		Root.CFrame = CFrame.new(89, 23, 2326)
	end)
	repeat wait() until Puzzle.IsOpen or Robbery.PowerPlant.Open == false
    if Robbery.PowerPlant.Open == false then
		disconnectStep("openPuzzle")
        return
    end
    if Puzzle.IsOpen then
        for i,v in pairs(Puzzle.Grid) do
            for i2,v2 in pairs(v) do
                v[i2] = v2 + 1
            end
        end
        local solution = Services.HttpService:JSONDecode((syn and syn.request or http_request or request)({
            Url = "https://numberlink-solver.sagesapphire.repl.co",
            Method = "POST",
            Body = Services.HttpService:JSONEncode({
                Matrix = Puzzle.Grid
            }),
            Headers = {
                ["Content-Type"] = "application/json"
            }
        }).Body).Solution
        for i,v in pairs(solution) do
            for i2,v2 in pairs(v) do
                v[i2] = v2 - 1
            end
        end
        Puzzle.Grid = solution
        Puzzle.OnConnection()
        repeat wait() until not Puzzle.IsOpen
    end
	disconnectStep("openPuzzle")
    teleport(Vector3.new(95, 26, 2334), "linear", 2)
    teleport(Vector3.new(145, 26, 2290), "linear")
    teleport(Vector3.new(206, 21, 2241), "linear")
    teleport(Vector3.new(143, -3, 2095), "linear")
    teleport(Vector3.new(120, -9, 2100), "linear")
	connectStep("openPuzzle", function()
		Root.CFrame = CFrame.new(120, -9, 2100)
	end)
    repeat wait() until Puzzle.IsOpen or Robbery.PowerPlant.Open == false
    if Robbery.PowerPlant.Open == false then
		disconnectStep("openPuzzle")
        return
    end
    if Puzzle.IsOpen then
        for i,v in pairs(Puzzle.Grid) do
            for i2,v2 in pairs(v) do
                v[i2] = v2 + 1
            end
        end
        local solution = Services.HttpService:JSONDecode((syn and syn.request or http_request or request)({
            Url = "https://numberlink-solver.sagesapphire.repl.co",
            Method = "POST",
            Body = Services.HttpService:JSONEncode({
                Matrix = Puzzle.Grid
            }),
            Headers = {
                ["Content-Type"] = "application/json"
            }
        }).Body).Solution
        for i,v in pairs(solution) do
            for i2,v2 in pairs(v) do
                v[i2] = v2 - 1
            end
        end
        Puzzle.Grid = solution
        Puzzle.OnConnection()
        repeat wait() until not Puzzle.IsOpen
    end
	disconnectStep("openPuzzle")
    teleport(Vector3.new(109, -9, 2106), "linear", 2)
    teleport(Vector3.new(65, -5, 2099), "linear", 3)
    teleport(Vector3.new(33, -12, 2110), "linear", 3)
    teleport(Vector3.new(35, -15, 2142), "linear", 3)
    teleport(Vector3.new(50, -9, 2176), "linear", 3)
    teleport(Vector3.new(74, 5, 2226), "linear", 3)
    teleport(Vector3.new(97, 17, 2265), "linear", 3)
    teleport(Vector3.new(97, 22, 2265), "linear", 3)
    teleport(Vector3.new(60, 24, 2300), "linear", 4)
	if LocalPlayer.PlayerGui:FindFirstChild("PowerPlantRobberyGui") then
		attemptSell()
		Robbery.PowerPlant.Open = false
	end
end
function robPassenger()
	local briefcaseCount = 0
	for i,v in pairs(Specs) do
        if v.Name == "Grab briefcase" then
            v:Callback(true)
			briefcaseCount += 1
			wait()
        end
    end
	if isBagFull() or (LocalPlayer.PlayerGui.RobberyMoneyGui.Enabled and briefcaseCount == 0) then
		attemptSell()
		Robbery.NightTrain.Open = false
	end
end
function robPlane()
	Escape()
	repeat
		if Character:FindFirstChild("InVehicle") then
			local currentVehicle = GetLocalVehiclePacket().Model
			local root = currentVehicle.PrimaryPart
            local BV = Create("BodyVelocity", root, {
                Velocity = Vector3.new(),
                MaxForce = Vector3.new(1,1,1) * 9e9
            })
			repeat
				root.CFrame = CFrame.new(workspace.Plane.PrimaryPart.Position) + Vector3.new(0, 4, 0)
				for i,v in pairs(Specs) do
                    if v.Name == "Inspect Crate" then
                        v:Callback(true)
                    end
                end
				wait()
			until isBagFull() or not Character:FindFirstChild("InVehicle")
			BV:Destroy()
		else
			findEnterVehicle()
		end
	until isBagFull()
	if isBagFull() then
		wait(1)
		repeat
			teleport(Vector3.new(-342, 26, 2015), "vehicle")
			wait(20)
			teleport(Vector3.new(-342, 26, 2051), "vehicle")
			wait(1)
		until not isBagFull()
		Robbery.Plane.Open = false
	end
end

function robDonut()
	Escape()
	teleport(Vector3.new(121, 20, -1637), "vehicle")
	wait(0.5)
	attemptJump()
	Root.CFrame = CFrame.new(121, 20, -1632)
	teleport(Vector3.new(109, 22, -1587), "linear")
	teleport(Vector3.new(85, 20, -1596), "linear", 2)
	connectStep("dontmove", function()
		Root.CFrame = CFrame.new(85, 20, -1596)
	end)
	for i,v in pairs(require(game.ReplicatedStorage.Module.UI).CircleAction.Specs) do
		if v.Name == "Rob" and (v.Part.Position - Root.Position).Magnitude < 20 then
			v:Callback(false)
			wait(10)
			v:Callback(true)
			break
		end
	end
	disconnectStep("dontmove")
	teleport(Vector3.new(109, 22, -1587), "linear", 2)
	teleport(Vector3.new(121, 20, -1637), "linear")
	Robbery.Donut.Open = false
end

function robGas()
	Escape()
	teleport(Vector3.new(-1639, 20, 694), "vehicle")
	wait(0.5)
	attemptJump()
	Root.CFrame = CFrame.new(-1629, 20, 694)
	teleport(Vector3.new(-1611, 20, 690), "linear")
	teleport(Vector3.new(-1600, 18, 684), "linear", 2)
	connectStep("dontmove", function()
		Root.CFrame = CFrame.new(-1600, 18, 684)
	end)
	for i,v in pairs(require(game.ReplicatedStorage.Module.UI).CircleAction.Specs) do
		if v.Name == "Rob" and (v.Part.Position - Root.Position).Magnitude < 20 then
			v:Callback(false)
			wait(10)
			v:Callback(true)
			break
		end
	end
	disconnectStep("dontmove")
	teleport(Vector3.new(-1611, 20, 690), "linear")
	teleport(Vector3.new(-1639, 20, 694), "linear")
	Robbery.Gas.Open = false
end

while getgenv().autorob do
	if Robbery.Jewelry.Open then
		robJewelry()
	elseif Robbery.PowerPlant.Open then
		robPower()
	elseif Robbery.NightTrain.Open then
		robPassenger()
	elseif Robbery.CargoPlane.Open and workspace.Plane.PrimaryPart.Position.Y > 110 and #workspace.Plane:FindFirstChild("Crates"):GetChildren() > 0 then
		robPlane()
	elseif Robbery.Donut.Open then
		robDonut()
	elseif Robbery.Gas.Open then
		robJewelry()
	else
		wait(0.5)
	end
end
