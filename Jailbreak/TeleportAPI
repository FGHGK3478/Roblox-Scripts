if not game:IsLoaded() then game.Loaded:Wait() end
if not game.Players.LocalPlayer.PlayerGui:FindFirstChild("HotbarGui") then repeat wait() until game.Players.LocalPlayer.PlayerGui:FindFirstChild("HotbarGui") end

local Functions = {}
local partsNoclipable = {}

for i,d in pairs(workspace:GetDescendants()) do
    if d:IsA("Model") or d:IsA("Folder") then
        if game.Players:FindFirstChild(d.Name) or d.Name == "Rain" or d.Name == "Vehicles" or d.Name == "VehicleSpawns" or d.Name == "Trains" or d.Name == "CargoPlane" or d.Name == "CargoShip" then
            table.insert(partsNoclipable, d)
        elseif d.Name == "SwingDoor" or d.Name == "SlideDoor" then
        	d:Destroy()
        end
    elseif d:IsA("BasePart") then
        if not d.CanCollide then
            table.insert(partsNoclipable, d)
        end
    end
end
workspace.DescendantAdded:Connect(function(d)
    if d:IsA("Model") or d:IsA("Folder") then
        if game.Players:FindFirstChild(d.Name) or d.Name == "Rain" or d.Name == "Vehicles" or d.Name == "VehicleSpawns" or d.Name == "Trains" or d.Name == "CargoPlane" or d.Name == "CargoShip" then
            table.insert(partsNoclipable, d)
        elseif d.Name == "SwingDoor" or d.Name == "SlideDoor" then
        	d:Destroy()
        end
    elseif d:IsA("BasePart") then
        if not d.CanCollide then
            table.insert(partsNoclipable, d)
        end
    end
end)

require(game.ReplicatedStorage.Game.Paraglide).IsFlying = function()
    return tostring(getfenv(2).script) == "Falling"
end

--/Functions
local function jump()
    game:GetService("VirtualInputManager"):SendKeyEvent(true, "Space", false, game)
    wait()
    game:GetService("VirtualInputManager"):SendKeyEvent(not true, "Space", false, game)
end

local function create(instanceName, property)
    local instance = Instance.new(instanceName)
    for k,v in pairs(property) do
        instance[k] = v
    end
    return instance
end

local function createPath(startPos, endPos)
    if endPos.Y > startPos.Y then
        local path = game:GetService("PathfindingService"):CreatePath()
        path:ComputeAsync(endPos, startPos)
        if path.Status ~= Enum.PathStatus.NoPath then
            --/Reverse a waypoints
            local waypoints = path:GetWaypoints()
            local reversedwaypoints = {}
            for i = #waypoints, 1, -1 do
                local waypoint = waypoints[i]
                table.insert(reversedwaypoints, waypoint)
            end
            return reversedwaypoints
        end
    else
        local path = game:GetService("PathfindingService"):CreatePath()
        path:ComputeAsync(startPos, endPos)
        if path.Status ~= Enum.PathStatus.NoPath then
            --/Reverse a waypoints
            local waypoints = path:GetWaypoints()
            return waypoints
        end
    end
    return nil
end

local function findexitFromVector3(vec)
    -- Nothing to see here ;)
    local _, exitPos = workspace:FindPartOnRayWithIgnoreList(Ray.new(vec + Vector3.new(0, 1000, 0), Vector3.new(0, -1000, 0)), partsNoclipable)
    if exitPos then
        local waypoints = createPath(vec, exitPos)
        local exitWaypoints = {}
        if waypoints then
            for i,waypoint in pairs(waypoints) do
                table.insert(exitWaypoints, waypoint)
                local isPartBlockedAbove = workspace:FindPartOnRayWithIgnoreList(Ray.new(waypoint.Position, Vector3.new(0, 1000, 0)), partsNoclipable)
                if not isPartBlockedAbove then
                    return waypoint.Position, exitWaypoints
                end
            end
        end
    end
    for yi = vec.Y - 60, vec.Y + 60, 10 do
        local exits = {}
        for xi = vec.X - 300, vec.X + 300, 30 do
            for zi = vec.X - 300, vec.X + 300, 30 do
                local isOnMidAir = not workspace:FindPartOnRayWithIgnoreList(Ray.new(Vector3.new(xi, yi, zi), Vector3.new(0, -10, 0)), partsNoclipable)
                local isPartBlockedAbove = workspace:FindPartOnRayWithIgnoreList(Ray.new(Vector3.new(xi, yi, zi), Vector3.new(0, 1000, 0)), partsNoclipable)
                if not (isOnMidAir and isPartBlockedAbove) then
                    table.insert(exits, Vector3.new(xi, yi, zi))
                end
            end
        end
        if #exits > 0 then
            table.sort(exits, function(one, two)
                return (one - vec).Magnitude < (two - vec).Magnitude
            end)
            for i,exit in pairs(exits) do
                local isOnMidAir = not workspace:FindPartOnRayWithIgnoreList(Ray.new(exit, Vector3.new(0, -10, 0)), partsNoclipable)
                local isPartBlockedAbove = workspace:FindPartOnRayWithIgnoreList(Ray.new(exit, Vector3.new(0, 1000, 0)), partsNoclipable)
                local exitWaypoints = {}
                if not (isOnMidAir and isPartBlockedAbove) then
                    local waypoints = createPath(vec, exit)
                    if waypoints then
                        for i2,waypoint in pairs(waypoints) do
                            table.insert(exitWaypoints, waypoint)
                            local isPartBlockedAbove = workspace:FindPartOnRayWithIgnoreList(Ray.new(waypoint.Position, Vector3.new(0, 1000, 0)), partsNoclipable)
                            if not isPartBlockedAbove then
                                return waypoint.Position, exitWaypoints
                            end
                        end
                    end
                end
            end
        end
    end
end

function Functions:Teleport(cframe, speed, direction)
    local char = game.Players.LocalPlayer.Character
    local rootpart = char and char:FindFirstChild("HumanoidRootPart")
    local human = char and char:FindFirstChild("Humanoid")
    if not (human and rootpart) then
        return
    end
    if cframe == nil then
        cframe = CFrame.new(0, 20, 0)
    end
    if speed == nil then
        speed = 100
    end
    local move = create("BodyVelocity", {
        ["Parent"] = rootpart,
        ["Velocity"] = Vector3.new(),
        ["MaxForce"] = Vector3.new(1, 1, 1) * math.huge,
        ["P"] = math.huge
    })
    if direction == "up" then
        local isPartBlockedAbove = workspace:FindPartOnRayWithIgnoreList(Ray.new(rootpart.Position, Vector3.new(0, 1000, 0)), partsNoclipable)
        if isPartBlockedAbove then
            print('blocked')
            local exit, waypoints = findexitFromVector3(rootpart.Position)
            print(exit, waypoints)
            if exit and waypoints then
                for i,waypoint in pairs(waypoints) do
                    local waypointDestination = waypoint.Position + Vector3.new(0, 4, 0)
                    if waypoint.Action == Enum.PathWaypointAction.Jump then
                        if waypointDestination.Y < rootpart.Position.Y then
                            waypointDestination = Vector3.new(waypoint.Position.X, rootpart.Position.Y, waypoint.Position.Z)
                        end
                    end
                    local sharpTurn = waypoints[i - 2] and waypoints[i + 2] and workspace:FindPartOnRayWithIgnoreList(Ray.new(waypoints[i - 2].Position + Vector3.new(0, 4, 0), (waypoints[i + 2].Position - waypoints[i - 2].Position) + Vector3.new(0, 4, 0)), partsNoclipable)
                    local tween = game:GetService("TweenService"):Create(rootpart, TweenInfo.new((waypointDestination - rootpart.Position).Magnitude / 100, Enum.EasingStyle.Linear), {CFrame = CFrame.new(waypointDestination)})
                    tween:Play()
                    tween.Completed:Wait()
                    if sharpTurn then
                        wait(0.3)
                    end
                end
                move.Velocity = Vector3.new()
                wait(0.3)
            end
        end
        rootpart.CFrame = CFrame.new(rootpart.CFrame.X, 1000, rootpart.CFrame.Z)
        wait()
        local destinationTime = (CFrame.new(cframe.X, 1000, cframe.Z).p - rootpart.Position).Magnitude / speed
        local currenttime = tick()
        while tick() - currenttime < destinationTime + 10 and (CFrame.new(cframe.X, 1000, cframe.Z).p - rootpart.Position).Magnitude > (speed / 50) do
            move.Velocity = (CFrame.new(cframe.X, 1000, cframe.Z).p - rootpart.Position).Unit * speed
            wait()
        end
        move.Velocity = Vector3.new()
        local partBlocked, blockedPosition = workspace:FindPartOnRayWithIgnoreList(Ray.new(rootpart.Position, cframe.p - rootpart.Position), partsNoclipable)
        if partBlocked then
            rootpart.CFrame = CFrame.new(blockedPosition) + Vector3.new(0, 4, 0)
            local waypoints = createPath(rootpart.Position, cframe.p)
            if waypoints then
                for i,waypoint in pairs(waypoints) do
                    local waypointDestination = waypoint.Position + Vector3.new(0, 4, 0)
                    if waypoint.Action == Enum.PathWaypointAction.Jump then
                        if waypointDestination.Y < rootpart.Position.Y then
                            waypointDestination = Vector3.new(waypoint.Position.X, rootpart.Position.Y, waypoint.Position.Z)
                        end
                    end
                    local sharpTurn = waypoints[i - 2] and waypoints[i + 2] and workspace:FindPartOnRayWithIgnoreList(Ray.new(waypoints[i - 2].Position + Vector3.new(0, 4, 0), (waypoints[i + 2].Position - waypoints[i - 2].Position) + Vector3.new(0, 4, 0)), partsNoclipable)
                    local tween = game:GetService("TweenService"):Create(rootpart, TweenInfo.new((waypointDestination - rootpart.Position).Magnitude / 100, Enum.EasingStyle.Linear), {CFrame = CFrame.new(waypointDestination)})
                    tween:Play()
                    tween.Completed:Wait()
                    if sharpTurn then
                        wait(0.3)
                    end
                end
                move.Velocity = Vector3.new()
                wait(0.3)
            end
        else
            rootpart.CFrame = cframe
        end
        wait()
        move:Destroy()
    else
        local isPartBlocked = workspace:FindPartOnRayWithIgnoreList(Ray.new(rootpart.Position, cframe.p - rootpart.Position), partsNoclipable)
        if isPartBlocked then
            local waypoints = createPath(rootpart.Position, cframe.p)
            if waypoints then
                for i,waypoint in pairs(waypoints) do
                    local waypointDestination = waypoint.Position + Vector3.new(0, 4, 0)
                    if waypoint.Action == Enum.PathWaypointAction.Jump then
                        if waypointDestination.Y < rootpart.Position.Y then
                            waypointDestination = Vector3.new(waypoint.Position.X, rootpart.Position.Y, waypoint.Position.Z)
                        end
                    end
                    local sharpTurn = waypoints[i - 2] and waypoints[i + 2] and workspace:FindPartOnRayWithIgnoreList(Ray.new(waypoints[i - 2].Position + Vector3.new(0, 4, 0), (waypoints[i + 2].Position - waypoints[i - 2].Position) + Vector3.new(0, 4, 0)), partsNoclipable)
                    local tween = game:GetService("TweenService"):Create(rootpart, TweenInfo.new((waypointDestination - rootpart.Position).Magnitude / 100, Enum.EasingStyle.Linear), {CFrame = CFrame.new(waypointDestination)})
                    tween:Play()
                    tween.Completed:Wait()
                    if sharpTurn then
                        wait(0.3)
                    end
                end
                move.Velocity = Vector3.new()
                wait(0.3)
            end
        end
        local destinationTime = (cframe.p - rootpart.Position).Magnitude / speed
        local currenttime = tick()
        while tick() - currenttime < destinationTime + 10 and (cframe.p - rootpart.Position).Magnitude > (speed / 50) do
            move.Velocity = (cframe.p - rootpart.Position).Unit * speed
            wait()
        end
        move.Velocity = Vector3.new()
        wait()
        rootpart.CFrame = cframe
        wait()
        move:Destroy()
    end
end

function Functions:TeleportWithVehicle(cframe, speed, vehicleName) -- Leave carName will teleport with camaro jeep an helicopter
    local lplr =  game.Players.LocalPlayer
    local char = lplr.Character
    local rootpart = char and char:FindFirstChild("HumanoidRootPart")
    local human = char and char:FindFirstChild("Humanoid")
    if human and rootpart == nil then
        return
    end
    while wait() do
        if human and rootpart == nil then
            return
        end
        if char:FindFirstChild("InVehicle") then
            local currentVehicle
            for i,v in pairs(workspace.Vehicles:GetChildren()) do
                if v:FindFirstChild("Engine") and v:FindFirstChild("Seat") and v.Seat:FindFirstChild("PlayerName") and v.Seat.PlayerName.Value == lplr.Name then
                    currentVehicle = v
                    break
                end
            end
            if vehicleName == nil or currentVehicle.Name == vehicleName then
                wait(1)
                local move = rootpart:FindFirstChild("MoveVehicle") or create("BodyVelocity", {Name = "MoveVehicle", Parent = rootpart})
                move.Velocity = Vector3.new()
                move.MaxForce = Vector3.new(1, 1, 1) * math.huge
                move.P = math.huge
                repeat wait()
                    if human == nil or human.Health <= 0 then
                        return
                    end
                    local isPartBlockedAbove = workspace:FindPartOnRayWithIgnoreList(Ray.new(rootpart.Position, Vector3.new(0, 1000, 0)), partsNoclipable)
                    if isPartBlockedAbove then
                        move.Velocity = Vector3.new()
                        local exit, waypoints = findexitFromVector3(rootpart.Position)
                        if exit and waypoints then
                            for i,waypoint in pairs(waypoints) do
                                local waypointDestination = waypoint.Position + Vector3.new(0, 4, 0)
                                if waypoint.Action == Enum.PathWaypointAction.Jump then
                                    if waypointDestination.Y < rootpart.Position.Y then
                                        waypointDestination = Vector3.new(waypoint.Position.X, rootpart.Position.Y, waypoint.Position.Z)
                                    end
                                end
                                local sharpTurn = waypoints[i - 3] and waypoints[i + 3] and workspace:FindPartOnRayWithIgnoreList(Ray.new(waypoints[i - 3].Position + Vector3.new(0, 4, 0), (waypoints[i + 3].Position - waypoints[i - 3].Position) + Vector3.new(0, 4, 0)), partsNoclipable)
                                if sharpTurn then
                                    move.Velocity = (waypointDestination - rootpart.Position).Unit * 21
                                    wait((waypointDestination - rootpart.Position).Magnitude / 21)
                                else
                                    move.Velocity = (waypointDestination - rootpart.Position).Unit * 100
                                    wait((waypointDestination - rootpart.Position).Magnitude / 100)
                                end
                            end
                        end
                    end
                    if rootpart.Position.Y < 499 then
                        for i,d in pairs(currentVehicle:GetDescendants()) do
                            if d:IsA("BasePart") then
                                d.CFrame = CFrame.new(d.CFrame.X, 500, d.CFrame.Z)
                            end
                        end
                    end
                    move.Velocity = (Vector3.new(cframe.X, 500, cframe.Z) - rootpart.Position).Unit * speed
                until not char:FindFirstChild("InVehicle") or (Vector3.new(cframe.X, 500, cframe.Z) - rootpart.Position).Magnitude < 5
                if not char:FindFirstChild("InVehicle") then
                    move.Velocity = Vector3.new()
                    wait()
                    move:Destroy()
                else
                    move.Velocity = Vector3.new()
                    for i,d in pairs(currentVehicle:GetDescendants()) do
                        if d:IsA("BasePart") then
                            d.CFrame = cframe
                        end
                    end
                    wait()
                    move:Destroy()
                end
                break
            else
                jump()
                wait(1)
            end
        else
            local nearestVehicles = {}
            local vehicleSpawns = {}
            local nearestSpawn
            for i,vs in pairs(workspace.VehicleSpawns:GetChildren()) do
                if vehicleName and vs.Name == vehicleName or not vehicleName and (vs.Name == "Camaro" or vs.Name == "Heli" or vs.Name == "Jeep") then
                    table.insert(vehicleSpawns,vs)
                end
            end
            table.sort(vehicleSpawns, function(one, two)
                return (one.Region.Position - rootpart.Position).Magnitude < (two.Region.Position - rootpart.Position).Magnitude
            end)
            nearestSpawn = vehicleSpawns[1]
            for i,v in pairs(workspace.Vehicles:GetChildren()) do
                if (vehicleName == nil and (v.Name == "Camaro" or v.Name == "Heli" or v.Name == "Jeep") or v.Name == vehicleName) and v:FindFirstChild("Seat") and v.Seat:FindFirstChild("PlayerName") and v.Seat.Player.Value == false then
                    local distanceFromVehicle = (v.Engine.Position - rootpart.Position).Magnitude -- lplr:DistanceFromCharacter(v.Engine.Position)
                    local distanceFromSpawn = (nearestSpawn.Region.Position - rootpart.Position).Magnitude -- lplr:DistanceFromCharacter(nearestSpawn.Region.Position)
                    if (distanceFromVehicle < distanceFromSpawn) or distanceFromVehicle < 500 then
                        table.insert(nearestVehicles, v)
                    end
                end
            end
            if #nearestVehicles > 0 then
                table.sort(nearestVehicles,function(one, two)
                    return (one.Engine.Position - rootpart.Position).Magnitude < (two.Engine.Position - rootpart.Position).Magnitude
                end)
            else
                repeat wait()
                    if human == nil or human.Health <= 0 then
                        return
                    end
                    if (nearestSpawn.Region.Position - rootpart.Position).Magnitude > 10 then
                        Functions:Teleport(nearestSpawn.Region.CFrame, 100, "up")
                        wait(0.5)
                    end
                    for i,v in pairs(workspace.Vehicles:GetChildren()) do
                        if (vehicleName and v.Name == vehicleName or not vehicleName and (v.Name == "Camaro" or v.Name == "Heli" or v.Name == "Jeep")) and v:FindFirstChild("Seat") and v.Seat:FindFirstChild("PlayerName") then
                            if (v.Engine.Position - rootpart.Position).Magnitude < 500 and v.Seat.Player.Value == false then
                                table.insert(nearestVehicles, v)
                                break
                            end
                        end
                    end
                until #nearestVehicles > 0
            end
            local nearestVehicle = nearestVehicles[1]
            repeat wait()
                if human == nil or human.Health <= 0 then
                    break
                end
                if (nearestVehicle.Engine.Position - rootpart.Position).Magnitude > 10 then
                    Functions:Teleport(nearestVehicle.Seat.CFrame, 100, "up")
                    wait(0.5)
                end
                for i,v in pairs(require(game.ReplicatedStorage.Module.UI).CircleAction.Specs) do
                    if v.Part == nearestVehicle.Seat then
                        v:Callback(v, true)
                    end
                end
                if lplr.PlayerGui.NotificationGui.ContainerNotification.Message.Text:match("Cannot use vehicle here") and lplr.PlayerGui.NotificationGui.Enabled then
                    lplr.PlayerGui.NotificationGui.Enabled = false
                    nearestVehicle.Name = "gay"
                    nearestVehicle = nil
                elseif nearestVehicle.Seat.Player.Value and nearestVehicle.Seat.PlayerName.Value ~= lplr.Name then
                    nearestVehicle.Name = "gAY"
                    nearestVehicle = nil
                end
                for i,v in pairs(lplr.PlayerGui:GetDescendants()) do
                    if v:IsA("TextLabel") then
                        if v.Text:match("That vehicle is locked") and v.Visible then
                            v.Visible = false
                            nearestVehicle.Name = "GAAAAYYYYYY"
                            nearestVehicle = nil
                            break
                        end
                    end
                end
            until char:FindFirstChild("InVehicle") or nearestVehicle == nil or nearestVehicle.Model.Body.Transparency > 0
        end
    end
end

return Functions
